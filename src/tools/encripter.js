const forge = require('node-forge');
require('dotenv').config();
const path = require('path');
const fs = require('fs');
const logger = require('./utils/TrencherLogger');

/**
 * Module for encripting and decripting based on node-forge
 * @module TrencherEncripter
 * @fileoverview This module contains function to encript and decript objects.
 * @author Daniel Galván Cancio
 */

let envKey = null;
let envIv = null;

console.log(process.env.ENCRIPTER_IV);

/**
 * Gets the encripting key and the Initizalization vector. If they dont exists, it creates
 * automatically them and injects it in your .env file.
 *
 * @returns {Object{key: String, iv: String}} Returns the encriptation key and the initialization
 * vector (autogenerated or from .env)
 *
 * @author Daniel Galván Cancio
 */
function getKeyAndIv() {
  let key = null;
  let iv = null;
  if (!process.env.ENCRIPTER_KEY || !process.env.ENCRIPTER_IV) {
    logger.warn(
      'There is no encripting key and no inizialization vector. System is generating them',
    );
    key = forge.random.getBytesSync(16);
    iv = forge.random.getBytesSync(16);
    const keyBase64 = forge.util.encode64(key);
    const ivBase64 = forge.util.encode64(iv);
    fs.appendFileSync('.env', `\nENCRIPTER_KEY=${keyBase64}`);
    fs.appendFileSync('.env', `\nENCRIPTER_IV=${ivBase64}`);
    envKey = key;
    envIv = iv;
    logger.warn('Encripting key and inizialization vector generated correctly');
  } else {
    key = forge.util.decode64(process.env.ENCRIPTER_KEY);
    iv = forge.util.decode64(process.env.ENCRIPTER_IV);
  }

  return { key, iv };
}

/**
 * Given an object and a list with the properties you want to encript, it
 * returns an object with all original properties, the ones who were on the list,
 * encripted, and the others with its initial values.
 *
 * The encripter key and initialation vector are picked form the .env, or autogenerated
 * if .env doesnt contain them.
 *
 * THE PROPERTIES TO ENCRIPT MUST BE ALWAYS STRINGS!!!!!
 * @param {object} [objectToEncript] - The object you want to encript.
 * @param {Array} [propertiesToEncript] - An array containing the properties you want to
 * encript
 * @returns {object} - It returns the initial object but the properties that
 * were on the list are now encripted
 * @author Daniel Galván Cancio
 */
function encryptPropertiesWithEnvValues(objectToEncript, propertiesToEncript) {
  const keyAndVector = getKeyAndIv();
  const key = keyAndVector.key;
  const iv = keyAndVector.iv;
  const encryptedObject = {};

  propertiesToEncript.forEach((property) => {
    if (objectToEncript.hasOwnProperty(property)) {
      let value = objectToEncript[property];
      const cipher = forge.cipher.createCipher('AES-CBC', key);
      cipher.start({ iv: iv });
      cipher.update(forge.util.createBuffer(value));
      cipher.finish();
      encryptedObject[property] = forge.util.encode64(cipher.output.getBytes());
    }
  });

  const nonEncryptedObject = {};

  for (let property in objectToEncript) {
    if (!propertiesToEncript.includes(property)) {
      nonEncryptedObject[property] = objectToEncript[property];
      encryptedObject[property] = objectToEncript[property];
    }
  }

  return encryptedObject;
}

/**
 * Given an encripted object whose encripted properties are on the list also given,
 * it returns the decripted object.
 *
 * The encripter key and initialation vector are picked form the .env, so if you dont
 * have them or the object wasnt encripted with them, you wont be able to decript the object.
 *
 * THE PROPERTIES TO DECRIPT MUST BE ALWAYS STRINGS!!!!!
 * @param {object} [encryptedObject] - The object you want to decript.
 * @param {Array} [propertiesToDecrypt] - An array containing the properties you want to
 * decript
 * @returns {object} - It returns the initial object but the properties that
 * were on the list are now decripted
 * @author Daniel Galván Cancio
 */
function decryptPropertiesWithEnvValues(encryptedObject, propertiesToDecrypt) {
  const key = process.env.ENCRIPTER_KEY
    ? forge.util.decode64(process.env.ENCRIPTER_KEY)
    : envKey;
  const iv = process.env.ENCRIPTER_IV
    ? forge.util.decode64(process.env.ENCRIPTER_IV)
    : envIv;
  envKey = null;
  envIv = null;
  const decryptedObject = {};

  propertiesToDecrypt.forEach((property) => {
    if (encryptedObject.hasOwnProperty(property)) {
      let value = encryptedObject[property];
      const decipher = forge.cipher.createDecipher('AES-CBC', key);
      decipher.start({ iv: iv });
      decipher.update(forge.util.createBuffer(forge.util.decode64(value)));
      decipher.finish();
      decryptedObject[property] = decipher.output.toString();
    }
  });

  for (let property in encryptedObject) {
    if (!propertiesToDecrypt.includes(property)) {
      decryptedObject[property] = encryptedObject[property];
    }
  }

  return decryptedObject;
}

/**
 * Given an object and a list with the properties you want to encript, it
 * returns an object with all original properties, the ones who were on the list,
 * encripted, and the others with its initial values.
 *
 * The encripter key and initialation vector are picked randomly
 *
 * THE PROPERTIES TO ENCRIPT MUST BE ALWAYS STRINGS!!!!!
 * @param {object} [objectToEncript] - The object you want to encript.
 * @param {Array} [propertiesToEncript] - An array containing the properties you want to
 * encript
 * @returns {object{encriptedObject: object, iv: string, key: string}} - It returns the initial object but the
 *  properties that were on the list are now encripted. Moreover it has 2 other properties,
 * iv (initialization vector) and key (encripted key), which are the ramdomly generated parameters
 * @author Daniel Galván Cancio
 */
function encryptPropertiesWithRamdomKey(objectToEncript, propertiesToEncript) {
  const key = forge.random.getBytesSync(16);
  const iv = forge.random.getBytesSync(16);

  const encryptedObject = {};

  propertiesToEncript.forEach((property) => {
    if (objectToEncript.hasOwnProperty(property)) {
      let value = objectToEncript[property];
      const cipher = forge.cipher.createCipher('AES-CBC', key);
      cipher.start({ iv: iv });
      cipher.update(forge.util.createBuffer(value));
      cipher.finish();
      encryptedObject[property] = forge.util.encode64(cipher.output.getBytes());
    }
  });

  const nonEncryptedObject = {};

  for (let property in objectToEncript) {
    if (!propertiesToEncript.includes(property)) {
      nonEncryptedObject[property] = objectToEncript[property];
      encryptedObject[property] = objectToEncript[property];
    }
  }

  return {
    encryptedObject: encryptedObject,
    iv: forge.util.encode64(iv),
    key: forge.util.encode64(key),
  };
}

/**
 * Given an encripted object whose encripted properties are on the list also given,
 * it returns the decripted object.
 *
 * The encripter key and initialation vector are picked form the .env, so if you dont
 * have them or the object wasnt encripted with them, you wont be able to decript the object.
 *
 * THE PROPERTIES TO DECRIPT MUST BE ALWAYS STRINGS!!!!!
 * @param {object} [encryptedObject] - The object you want to decript.
 * @param {Array} [propertiesToDecrypt] - An array containing the properties you want to
 * decript
 * @param {String} [keyBase64] The encriptation key used to encript the object, in base64
 * @param {String} [ivBase64]  The initialization vector used to encript the object, in base64
 *
 * @returns {object} - It returns the initial object but the properties that
 * were on the list are now decripted
 * @author Daniel Galván Cancio
 */
function decryptPropertiesWithRamdomKey(
  encryptedObject,
  keyBase64,
  ivBase64,
  propertiesToDecrypt,
) {
  const key = forge.util.decode64(keyBase64);
  const iv = forge.util.decode64(ivBase64);

  const decryptedObject = {};

  propertiesToDecrypt.forEach((property) => {
    if (encryptedObject.hasOwnProperty(property)) {
      let value = encryptedObject[property];
      const decipher = forge.cipher.createDecipher('AES-CBC', key);
      decipher.start({ iv: iv });
      decipher.update(forge.util.createBuffer(forge.util.decode64(value)));
      decipher.finish();
      decryptedObject[property] = decipher.output.toString();
    }
  });

  for (let property in encryptedObject) {
    if (!propertiesToDecrypt.includes(property)) {
      decryptedObject[property] = encryptedObject[property];
    }
  }

  return decryptedObject;
}

/**
 * Given an object that you want to encript, it
 * returns an object with all original properties, all of them
 * encripted.
 *
 * The encripter key and initialation vector are picked form the .env, or autogenerated
 * if .env doesnt contain them.
 *
 * THE PROPERTIES TO ENCRIPT MUST BE ALWAYS STRINGS
 * first.
 * @param {object} [objectToEncript] - The object you want to encript.
 * @returns {object} - It returns the initial object but with all properties now encripted
 * @author Daniel Galván Cancio
 */
function encriptHoleObjectWithEnv(objectToEncript) {
  const keyAndVector = getKeyAndIv();
  const key = keyAndVector.key;
  const iv = keyAndVector.iv;
  const encryptedObject = {};

  // Object.entries(objectToEncript).forEach(property => {
  //         let value = objectToEncript[property].toString();
  //         const cipher = forge.cipher.createCipher('AES-CBC', key);
  //         cipher.start({ iv: iv });
  //         cipher.update(forge.util.createBuffer(value));
  //         cipher.finish();
  //         encryptedObject[property] = forge.util.encode64(cipher.output.getBytes());
  // });

  Object.entries(objectToEncript).forEach(([property, value]) => {
    value = value.toString(); // Convertir el valor a una cadena si es necesario
    const cipher = forge.cipher.createCipher('AES-CBC', key);
    cipher.start({ iv: iv });
    cipher.update(forge.util.createBuffer(value));
    cipher.finish();
    encryptedObject[property] = forge.util.encode64(cipher.output.getBytes());
  });

  return encryptedObject;
}

// tests in case it fails
const object3 = {
  name: 'John',
  age: 30,
  email: 'john@example.com',
};

const propertiesToEncrypt2 = ['name', 'email'];

console.log('Original Object:', object3);

const encryptedObject3 = encryptPropertiesWithEnvValues(
  object3,
  propertiesToEncrypt2,
);
console.log('Encrypted Object with env values:', encryptedObject3);

const decryptedObject3 = decryptPropertiesWithEnvValues(
  encryptedObject3,
  propertiesToEncrypt2,
);
console.log('Decrypted Object with env values:', decryptedObject3);

console.log('=======================');

const object = {
  name: 'Holaaaa',
  age: 30,
  email: 'hola@example.com',
};

console.log('Original Object:', object);

const encryptedObject = encryptPropertiesWithRamdomKey(
  object,
  propertiesToEncrypt2,
);
console.log('Encrypted Object with ramdom values:', encryptedObject);

const decryptedObject = decryptPropertiesWithRamdomKey(
  encryptedObject.encryptedObject,
  encryptedObject.key,
  encryptedObject.iv,
  propertiesToEncrypt2,
);
console.log('Decrypted Object with ramdom vallues:', decryptedObject);

module.exports = {
  encryptPropertiesWithEnvValues,
  decryptPropertiesWithEnvValues,
  encryptPropertiesWithRamdomKey,
  decryptPropertiesWithRamdomKey,
};
